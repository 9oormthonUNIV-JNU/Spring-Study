##### Spring Security 1강 환경설정
1.Mysql 데이터 베이스 만들기
2. 프로젝트 만들기 - 의존성 설정
- Lombok, Spring boot DevTools, Spring Data Jpa, Spring Web, MYSQL Driver, Spring Security, Mustache 
3. application.yml 설정
4.Controller 패키지
-> view 리턴

5.mustach 사용 
-> 기본 폴터는 src/main/resorces
-> view resolver
6.mvc 삭제 -> spring security에서 자동 설정 됨
7.템플릿 생성 -> ~/index_mustach을 자동으로 찾는다.
8. Config 설정 -> WebMvcConfig 설정
* Spring Security 6.1 버전
  - WebSEcurityConfigureAdapter가 deprecated됨
    => SecurityFilterChain Bean을 생성하는 방식
    => lamda 함수 형식으로 하나의 요소는 하나의 메서드 안에서 처리하도록 변경됨.
    
##### 2강 시큐리티 설정
/login -> SpringSecurity가 낚아채서 진행 -> security config 생성 후 작동  X
@EnableWebSecurity -> Spring Security Filter 가 Filter chain에 등록
* Spring Security 6.1 버전
  - antmacher deptrecated
    => requestmacher 사용

##### 3강,4강 시큐리티 회원가입
Spring Security는 /login 요청이 오면 낚아채서 진행하는데, 로그인 진행이 완료되면 Security는 자신만의 세션을 만듬
-> Security Context Holder라는 키값에 정보 저장
-> 정보를 저장할 수 있는 오브젝트는 Authentication 객체 
-> Authentication 객체는 UserDetails 타입 객체를 가져야 함.

GrantedAuthority -> 해당 유저 권한 리턴
                 -> 리턴 시, user.Getrole()은 String 타입이므로 Colletion의 ArrayList를 활용하여 리턴
login_date -> 현재시간 - 로그인 시간 해서 휴먼계정 설정
로그인 요청이 오면 UserDEtailsService 타입으로 IOC 되어 있는 loadByUsername이 실행
loadByUsername에서의 findBy 규칙 -> Username 문법(Jpa Query method)

##### 5강 시큐리티 권한처리
@EnableGlobalMethodSecurity(Secured 어노테이션 활성화, prePostEnable 활성화)
@prePostEnable => preAuthorize 어노테이션 활성화 => 하위 소드 실행 직전에 실행.
@Secured => Secure 어노테이션 활성화하여 권한 설정

##### 12강 세션
*최초요청 시,
웹브라우저에서 서버에 get 방식으로 요청 -> 서버는 컨트롤러에서 요청을 찾고, 목록에 세션 id를 만들고,  http 헤더의 쿠키에 세션 id가 담김

* 두번째 요청 시
서버는 세션id를 찾아 인식하여 첫 사용자가 아닌 것을 판단.

*세션이 사라지는 경우
1.강제로 세션 날릴 때
2.사용자가 브라우저를 다 종료시킬때
3.특정시간(보통 30분)이 지났을때

*로그인 프로세스
클라이언트 -> 세션이라는 저장소에 세션 id 만듬 -> 응답해줄때 헤더에 세션 id를 돌려줌 -> 클라이언트 브라우저에 세션 id 저장
-> 로그인 요청 -> 데이터베이스에 값 호가인 -> 유저 정보 저장 -> main페이지로 리턴 -> 데이터 응답 -> 데이터 돌려줌

단점
클라이언트가 너무 많으면 서버가 여러개 만들어져서 분산됨
-> 클라이언트 로그인 오류
해결방법 - sticky server 생성 등으로 해결
         - 세션 복제
            -> 정보를 DB에 저장해놓고 공통으로 사용
                => 하드 디스크에서 세션 아이디를 찾기 때문에 느려짐
                => 느려지기 때문에 보통 메모리 서버 사용 대표적으로 redis.

##### 13강 tcp
통신 osi 계층
응용 : 데이터 던짐
프레젠테이션 : 데이터 압축,암호화
세션 : 인증되어 있는 지 확인
트랜스포트 - tcp :신뢰성 있는 통신으로 데이터가 잘 갔는지 확인함(=느려짐) ==> 보통 웹
           - udp :신뢰성 없는 통신으로, 데이터가 잘 갔는지 확인하지 않음(빠름) => 보통 사람이 이해 가능한 곳에 쓰임
네트워크 : ip
데이터 링크 : lan(근거리 통신)으로 공유기 찾읍
물리

=> 해당 방식으로 데이터가 전송됨

##### 14강 CIA
CIA(기민성, 무결성(변경), 가용성)이 깨지면 보안이 안됨.


-가용성 유지를 위해 데이터를 암호화 해야함.
  - 암호화한 데이터를 풀기위한 열쇠가 데이터를 전송받는 쪽에도 있어야 함.
  ==> 열쇠 전달 문제
- 열쇠 전달 문제 해결을 위해 데이터에 대한 응답(Ack)을 데이터를 전달하는 쪽이 받아야 하는데 해당 응답이 데이터를 전송받는 쪽에서 왔다는 보장이 없음
  ==> 응답이 누구로부터 왔는지에 대한 인증 문제

##### 15강 RSA(암호화)
public Key : 공개키
private Key : 개인키
키 하나로 사용 : 시멘트릭키

데이터를 받는 쪽의 공개키로 암호화하여 데이터 전송 -> 데이터 받는 쪽의 개인키로 데이터 접근 가능 -> 열쇠 전달 문제 해결(암호화)
데이터를 주는 쪽의 개인키로 암호화항 데이터 전송 -> 데이터 받는 쪽이 데이터를 주는 쪽의 공개키로 접근 가능 -> 인증 문제 해결(전자 문서 서명 인증)

데이터를 받는 쪽의 공개키로 암호화하고 데이터를 주는 쪽의 개인키로 감쌈 -> 데이터 받는 쪽에서 데이터를 주는 쪽의 공개키로 열어봄
                                                                       -> 열리면 인증 O -> 데이터를 받는 쪽의 개인키로 열어봄
                                                                        -> 안열리면 인증 X ==> 두 가지 문제 모두 해결

##### 16강 RFC
http : 벨 연구소 
서로 다른 그룹에서 통신하기 위해 약속된 규칙 필요 
   => RFC 1번 문서(프로토콜)
또 다른 그룹과 통신하기 위한 약속된 규칙 => RFC 2번 문서 
이런 방식으로 늘어남 => WWW(인터넷) 형성, http 프로토콜 = RFC 문서 통칭

JWT : RFC 7519에 만들어진 웹 토큰



