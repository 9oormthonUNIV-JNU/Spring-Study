# 섹션 1 : 프로젝트 환경 설정

## 내용 요약
1. 스프링 부트는 개발의 편의를 위해 설계된 프레임워크로, 의존성 추가 시 필요한 라이브러리들을 자동으로 가져와, 사용자가 직접 버전을 설정하지 않아도 스프링 부트가 호환되는 버전을 제공하여, 쉽게 개발을 시작할 수 있게 해줍니다.

2. 스프링 부트는 컨테이너리스 웹 애플리케이션 아키텍처를 지원합니다. 덕분에  스프링 부트의 메인 메소드만 실행하면 웹 애플리케이션을 쉽게 구동하고 개발할 수 있습니다.

3. slf4j와 logback은 자바에서 로깅을 관리하기 위해 사용되는 라이브러리입니다.
4. Spring Boot에서 View 환경 설정은 기본적으로 templates/{ViewName}.html 경로를 사용하며, application.yml 파일을 통해 수정 가능합니다.

## 환경 설정
spring boot version : 3.2.2

java version : 17

gradle 사용

dependency : 타임리프, spring-web

---

## 라이브러리 살펴보기

의존성을 추가할 때, 스프링 부트는 필요한 라이브러리들을 다 가져와 편하게 개발을 할 수 있게 해줍니다. ( 내장 톰캣 등 )
예시로, web 을 의존성 추가할 경우 그 안에 필요한 의존 라이브러리들을 함께 가져옵니다.

왜 그런가 하면, 스프링 부트를 만든 철학에 대해 알 필요가 있습니다.

### 1, 스프링 부트는 강한 자기 주장을 가진 도구이다.

우리가 의존성을 추가할 때, 우리가 직접 버전을 설정해줄 수도 있지만, 그렇지 않더라도 잘 동작하는 걸 볼 수 있습니다.

![image](https://github.com/choboss00/Spring-Study/assets/111727212/56e8e2ad-9944-4552-bd95-58d677b1f46f)

이처럼 우리는 **스프링 부트가 추천해주는 구성과 설정**을 이용하여 쉽게 개발을 시작할 수 있으며, 스프링에 대해 잘 모르더라도 스프링 부트가 추천해주는 대로 설정만 하면 스프링을 잘 활용할 수 있게 됩니다.

### 2. 컨테이너리스 웹 애플리케이션 아키텍처 지원

강사님이 말씀하시던 톰캣을 내장서버로 함께 띄운다는 의미를 조금만 더 깊게 생각해볼 필요가 있습니다.

일반적으로 스프링을 이용해 개발을 하는 경우, 웹 클라이언트와 서버 간 메시지 전달 방식은 다음과 같습니다.

WEB CLIENT 에서 요청을 보냄 → Servlet Container 에 존재하는 서블릿 중 하나인 디스패처 서블릿이 요청을 받게 됨 → 이후 요청을 처리할 빈 ( 컨트롤러 ) 을 찾아서 전달해줌 → 응답

이 과정에서 서블릿 컨테이너는 Tomcat 과 같은 서버를 말하며, 스프링 컨테이너는 우리가 인텔리제이 ( 혹은 sts, 이클립스 ) 에서 실행하는 스프링 서버를 의미합니다.

![image](https://github.com/choboss00/Spring-Study/assets/111727212/4cb11fa8-aec6-4222-97b6-27b9673f5704)

스프링 부트가 없던 시절, 스프링만 사용하여 배포를 하기 위해선 다음과 같은 과정을 거쳐야만 했습니다.

1. 톰캣 같은 웹 애플리케이션 서버 ( WAS ) 설치
3. 애플리케이션 코드를 WAR 로 빌드
4. 빌드한 WAR 파일을 WAS 로 옮기고 WAS 실행 ( 배포 )

이러한 작업은 개발 환경 설정과 배포 과정이 복잡하다는 단점이 존재했고, 각 프로그램의 버전이 올라감에 따라 설정을 전부 다시해줘야한다는 문제점이 존재했었습니다.

![image](https://github.com/choboss00/Spring-Study/assets/111727212/4cb11fa8-aec6-4222-97b6-27b9673f5704)

이러한 번거로움을 해결하고자, 컨테이너리스 ( Containerless ) 웹 애플리케이션 아키텍처에 대한 요구가 생겨나게 되었고, 여기서 말하는 컨테이너란 **톰캣과 같은 서블릿 컨테이너**를 의미합니다.

![image](https://github.com/choboss00/Spring-Study/assets/111727212/61f94bd8-93b8-42e0-8a22-e1e086687039)

서블릿 컨테이너란 우리가 등록한 서블릿들을 관리해주는 역할을 하며, 서비스가 동작하는 동안 메모리에 계속 떠있을 수 있도록 관리해주는 역할을 합니다.

원래라면 서블릿 컨테이너를 띄우기 위해 Tomcat 서버 ( 서블릿 컨테이너 ) 를 직접 설치하고 설정해 띄울 필요가 있습니다.

하지만 컨테이너리스 웹 애플리케이션 아키텍처를 지원해주는 경우, 이 번거로운 서블릿 컨테이너에 대한 준비를 직접 하지 않아도 됩니다. ( 스프링 부트가 이러함 )

즉 컨테이너리스 웹 애플리케이션 아키텍처란 **서블릿 컨테이너에 대한 준비를 직접 하지 않아도 되는 방식**을 의미합니다.

![image](https://github.com/choboss00/Spring-Study/assets/111727212/5f7881d0-6e80-4961-80dc-a283129b8b7f)

덕분에 서블릿 컨테이너에 대한 설정을 하지 않더라도, 스프링 부트가 자동으로 설정해서 서블릿 컨테이너를 띄워주며, 우리는 메인 메소드만 실행하면 서블릿 컨테이너가 동작하는 걸 확인해볼 수 있습니다.

![image](https://github.com/choboss00/Spring-Study/assets/111727212/4d6d46d8-3f28-4d17-8837-7b1f11048448)

## 참고
1. 토비의 스프링 부트 - 인프런
2. https://mangkyu.tistory.com/295

---
## slf4j, logback

일반적으로 디버깅을 하며 정보들을 표현하기 위한 방법으로 system.out.println() 을 자주 사용했었는데, 이는 프로그램의 성능을 떨어트리고 로그를 파일에 모아 저장하지 못합니다.

그래서 자바에서 지원하는 logging 라이브러리르 사용해서 로그를 관리합니다.

기존 표준으로 많이 사용되던 라이브러리는 log4j 이며, 이를 업그레이드 한 것이 logback 라이브러리입니다.

logback 라이브러리는 Slf4j 의 구현체로, spring boot 에서는 spring-boot-starter-logging 안에 기본적으로 포함되어 있어 따로 의존성을 추가하지 않더라도 자동으로 등록됩니다.

Slf4j 는 다양한 로깅 프레임워크에 대한 인터페이스 역할을 하기 때문에 다양한 로깅 라이브러리들을 하나의 통일된 방식으로 사용할 수 있게 됩니다.

## 출처
1. https://primetime.tistory.com/entry/Spring-Boot-%EB%A1%9C%EA%B7%B8-%EA%B4%80%EB%A6%AC-logback%EA%B3%BC-Slf4j
2. https://livenow14.tistory.com/63

---
## View 환경설정

컨트롤러에서 리턴 값으로 문자를 반환하면 viewResolver 가 화면을 찾아서 처리해줍니다.

기본적으로 설정된 경로는 templates/ + {ViewName} + .html 입니다.

만약 이를 바꾸고 싶다면, application.yml 파일에서 프로퍼티를 직접 설정해줄 수 있습니다.

![image](https://github.com/choboss00/Spring-Study/assets/111727212/457e64b5-ac74-4ab2-9763-d36e0acfdb1a)

thymeleaf 의 prefix 를 다른 경로로 수정해주면, 다른 경로의 html 파일을 읽어올 수 있습니다.

역시 suffix 를 .html 이 아닌 다른 이름으로 바꿔주면, 이제는 html 파일이 아닌 다른 파일을 읽을 수 있게 됩니다.

예시로, prefix 경로를 /test 로 바꿔주면, 이젠 templates 에서는 경로를 읽지 못하게 됩니다.

![image](https://github.com/choboss00/Spring-Study/assets/111727212/5b6886a5-0ce5-4db4-a771-c168df2fbbcf)
![image](https://github.com/choboss00/Spring-Study/assets/111727212/2f6a30c7-f222-47fe-a8e0-2ca137fe4400)
( 환경 변수를 직접 주입해주니, 다른 경로를 통해 html 파일을 읽어오는 모습 )

이처럼 환경변수 ( 프로퍼티 ) 를 직접 다룰 수 있으면, 스프링 부트에 대해 조금 더 잘 이해할 수 있게 됩니다.

만약 톰캣의 기본 port 번호인 8080 을 바꾸고 싶다면, 다음과 같이 할 수 있습니다.

![image](https://github.com/choboss00/Spring-Study/assets/111727212/029fb90e-7ebc-4176-99c6-d10d90a96d99)
( 기본 포트 번호인 8080 )
![image](https://github.com/choboss00/Spring-Study/assets/111727212/57bdc6b6-be17-4e0e-87d9-6dd455aa5156)
( 환경변수를 주입한 포트번호 9999 가 나오는 모습 )

# 섹션 2 : 스프링 웹 개발 기초

## 내용 요약

1. 정적 컨텐츠: 웹 브라우저가 서버에게 요청한 파일을 그대로 전달하는 방식입니다. 

2. MVC와 템플릿 엔진: 서버에서 프로그래밍 작업을 거쳐 동적으로 컨텐츠를 생성하여 전달하는 방식입니다. 

3. API: JSON 데이터 포맷으로 클라이언트에게 데이터를 전달하는 방식입니다. @ResponseBody 어노테이션을 사용하면, viewResolver 대신 문자열이나 JSON 형태로 직접 데이터를 클라이언트에게 보낼 수 있습니다. 객체를 반환할 경우, HttpMessageConverter 인터페이스를 상속받는 JsonConverter가 작동하여 객체를 JSON으로 변환 후 전달합니다.

4. @RequestParam 어노테이션: 쿼리 파라미터로 값을 받기 위해 사용되며, name, value, required, defaultValue 등의 속성을 가집니다. required=true일 경우 쿼리 파라미터가 반드시 필요하며, defaultValue는 쿼리 파라미터가 없을 때 기본값을 설정할 수 있습니다.

5. 정적 컨텐츠와 동적 컨텐츠 처리 방식: 정적 컨텐츠는 서버가 요청 받은 파일을 그대로 클라이언트에 전달하는 반면, MVC와 템플릿 엔진을 사용하는 동적 컨텐츠는 서버에서 처리 후 결과를 클라이언트에 전달합니다. API를 통한 데이터 전송은 주로 JSON 형태로 클라이언트와 서버 간의 데이터를 교환할 때 사용됩니다.

## 정적 컨텐츠

정적 컨텐츠 : 파일을 그대로 웹브라우저에게 전달하는 것이라고 합니다.

MVC, 탬플릿 엔진 : 서버에서 프로그래밍 작업을 거친 뒤, 동적으로 전달하는 방식입니다.

API : JSON 데이터 포맷으로 클라이언트에게 데이터를 전달하는 방식입니다.

웹 브라우저 ( 클라이언트 ) 가 localhost:8080/hello-static.html 의 경로를 서버에게 요청할 때, 톰캣에서 먼저 리소스의 경로를 확인합니다.
![image](https://github.com/choboss00/Spring-Study/assets/111727212/e05c13be-32f8-4325-b23c-585320fddd56)

리소스가 들어왔을 때 먼저 다음과 같은 위치에서 파일이 있는지 찾아본 뒤, 해당하는 파일이 없을 경우 404 NOT FOUND 에러를 호출하게 됩니다.
![image](https://github.com/choboss00/Spring-Study/assets/111727212/61f6b414-de33-4eb3-8a9d-b4293040c46c)

![image](https://github.com/choboss00/Spring-Study/assets/111727212/f3a575fa-ed42-4a8d-aea8-e783b0b5f5cc)
( 강제로 환경 변수를 주입하여 /static 경로를 없애버리니, 404 에러가 발생하는 모습 )

다시 정상적으로 /static/ 경로를 추가하니, 파일을 잘 찾아오는 걸 확인해볼 수 있습니다.
![image](https://github.com/choboss00/Spring-Study/assets/111727212/c1a3cb8c-6113-4d96-bced-794ab467b637)

## MVC 와 템플릿 엔진

MVC : Model-View-Controller 의 줄임말입니다.

하나의 파일안에 로직을 다 넣어서 개발을 하던 방식에서 현재는 역할과 책임을 나눠 MVC 모델로 개발하는 방식으로 넘어왔습니다.

우리는 쿼리 파라미터로 특정 데이터를 서버로 넘겨줄 수 있는데, 다음과 같이 코드를 작성할 수 있습니다.

```java
    @GetMapping("hello-mvc")
    public String helloMvc(@RequestParam("name") String name, Model model) {
        model.addAttribute("name", name);
        return "hello-template";
```
이때 우리는 파라미터를 넘겨줄 수 있게 되며, name="aaa" 이런식으로 파라미터를 넘겨줄 수 있게 됩니다.

`@RequestParam` 의 내부 구현 어노테이션을 까보면, 다음과 같습니다.
![image](https://github.com/choboss00/Spring-Study/assets/111727212/5aae2c70-055a-4bba-8443-b51e74f096fe)

여기서 name, value 는 우리가 쿼리 파라미터로 값을 바인딩할 때 사용됩니다.

required 의 경우 기본 값이 true 인데, 이는 쿼리 파라미터를 무조건 담아야만이 정상적으로 실행됨을 의미합니다.

만약 required=false 로 설정할 경우, 쿼리 파라미터를 넣지 않더라도 잘 동작합니다.

마지막으로 defaultValue 의 경우, 요청이 들어왔을 때 임의의 값을 넣어주는 역할을 합니다.

위의 String name 을 예시로 보면, defaultValue 값을 만약 "aaa" 로 설정할 경우, 쿼리 파라미터를 전달하지 않더라도 기본값인 "aaa" 가 나오게 됩니다.

![image](https://github.com/choboss00/Spring-Study/assets/111727212/3f6bb446-1bd7-4f4d-9cc0-be1f10488af5)

템플릿 엔진을 이용한 요청과 응답을 그림으로 그려보면, 다음과 같습니다.
![image](https://github.com/choboss00/Spring-Study/assets/111727212/7c9d4c66-ee80-4cc7-9ff0-00d90c989426)

## 참고
1. https://dingdingmin-back-end-developer.tistory.com/entry/Springboot-MVC-%ED%8C%8C%ED%97%A4%EC%B9%98%EA%B8%B05-RequestParam

## API
정적 컨텐츠가 아닌 데이터를 전달하기 위한 방식으로는 크게 HTML, API 방식이 존재합니다.

`@ResponseBody` 어노테이션을 사용할 경우, viewResolver 를 사용하지 않고 문자열 그 자체를 화면에 보여주게 됩니다.

만약 문자열이 아닌 객체를 넘겨줄 경우, JSON 데이터를 화면에 보여주게 됩니다.

어떻게 JAVA 로 작성한 코드를 JSON 으로 변환할 수 있을까요?

먼저 그림을 보면 다음과 같습니다.
![image](https://github.com/choboss00/Spring-Study/assets/111727212/5846754a-2651-48bb-9355-622df626c2c8)

즉 `@ResponseBody` 어노테이션이 붙어있는 경우, 문자열인 경우 그대로 HTML 화면에 보여주게 됩니다.
- StringConverter 가 동작하여 문자열 그대로 보여줌

하지만 만약 객체가 올 경우, 그대로 보여줄 수 없기 때문에 JSON 방식으로 변환 후 HTML 화면에 보여주게 됩니다.
- JsonConverter 가 동작하여 JSON 으로 변환 후 보여줌

즉 HttpMessageConverter 를 상속받은 MappingJackson2HttpMessageConverter 클래스 ( JsonConverter ) 를 이용해 JSON 데이터를 변환하며, 이 과정에서 내부에 존재하는 ObjectMapper 클래스를 이용하여 JSON 으로 변환하게 됩니다.

![image](https://github.com/choboss00/Spring-Study/assets/111727212/2946f0b1-fb4a-4d37-9016-d48474d521a2)
( 저 밑줄을 쭉쭉 타고 가보면 HttpMessageConverter 를 상속받는다는걸 알 수 있음 )

## 참고
1. https://velog.io/@hanhyunsoo/Spring-ResponseBody-RequestBody%EC%9D%98-%EB%8F%99%EC%9E%91-%EB%B0%A9%EC%8B%9D

# 섹션 3 : 회원 관리 예제 - 백엔드 개발

## 내용 요약

1. 일반적인 웹 애플리케이션 계층 구조는 주로 Controller, Service, Repository, Domain 계층으로 구성됩니다.

2. 인터페이스를 활용하여 구현 클래스의 변경이 용이하도록 설계, 인터페이스를 통한 상속은 객체지향의 추상화를 활용, 유연한 설계를 가능하게 합니다.

3. JUnit 프레임워크를 사용하여 테스트 케이스를 작성하였고, 모든 테스트는 독립적으로 실행되어야 하며, @AfterEach 어노테이션을 사용하여 테스트 종료 후 데이터를 초기화함으로써 다른 테스트에 영향을 미치지 않게 할 수 있습니다.

4. 주요 로직과 서브 기능을 분리하여 메소드를 작성. 메소드 명명은 클래스의 역할과 기능을 반영하도록 합니다.

5. given-when-then 패턴을 사용하여 테스트를 구조화, 같은 MemberRepository 객체를 사용하기 위해 의존성 주입(DI, Dependency Injection) 방식을 적용, 서비스와 테스트 간에 동일한 객체 인스턴스를 공유하여 일관된 테스트 환경을 유지합니다.

## 비즈니스 요구사항 정리

비즈니스 요구 사항
- 데이터 : 회원 ID, 이름
- 기능 : 회원 등록, 조회
- 아직 데이터 저장소가 선정되지 않아서, 우선 인터페이스로 구현 클래스를 변경할 수 있도록 설계

일반적인 웹 애플리케이션 계층 구조
![image](https://github.com/choboss00/Spring-Study/assets/111727212/a9eab355-9cb9-4af7-a5b3-23fb624ce6f8)

## 회원 도메인과 리포지토리 만들기

jpa 를 사용하지 않고 직접 메소드를 구현해볼 수 있었습니다.

영한님 강의에서 인터페이스를 만들면서 이 인터페이스를 상속받아 구현 클래스를 만든다라는 내용이 있었는데, 만약 인터페이스를 상속하는 방식이 아닌 각각 A, B, C 등등의 클래스를 직접 만들어서 사용한다면 어떻게 될까요?


하지만, 만약 인터페이스로 상속을 받은 경우, 객체지향의 중요한 특징중 하나인 추상화 덕분에 인터페이스 하나만으로 A, B, C 등을 한번에 받을 수 있게 됩니다.

예시로, 장난감을 인터페이스로 선언하여 코드를 작성한 것과 , 그렇지 않은 걸 살펴보고자 합니다.
- 클래스 : 로봇

```java
// 예시 : 장난감을 상속받은 클래스가 1개 뿐 인 경우
Robot robot = new Robot();
... ( 다른 클래스에서도 로봇 객체를 만들어서 사용중 )
```

만약 새로운 장난감을 사서 장난감을 교체하는 경우, 로봇으로 객체를 만들어놓은 부분들을 모조리 수정해줄 필요가 있습니다.

그러면 장난감을 새로 교체할 때마다 클래스를 다시 수정할 필요가 있어, 매우 번거롭기 때문에 인터페이스를 활용하면 이 문제점을 해결할 수 있습니다.
- 인터페이스 : 장난감
- 장난감을 상속받은 클래스 : 로봇1, 로봇2, 로봇3

```java

public toy initToy(Toy toy) {
    toy t = null;

    if (toy.getName().equals("robot1") {
            toy = new Robot1();
    }
    else if ... 로봇 객체 받아주기

    return toy;
}
```

이 경우 새로운 장난감을 추가하더라도 아래에 if문 하나만 추가해주면 됩니다. 

( 설명이 좀 이상할수도.. 궁금하신 분들은 추상화에 대해 찾아보시면 좋을 듯 합니다 )

## 회원 리포지토리 테스트 케이스 작성

개발한 기능을 테스트할 때 main 메소드를 통해 실행하거나, 웹 애플리케이션의 컨트롤러를 통해서 해당 기능을 실행합니다.

하지만 이러한 방법은 시간이 오래 걸려 반복하기 어렵다라는 단점이 존재했기 때문에, 자바는 JUnit 이라는 프레임워크로 테스트를 실행해서 이러한 문제점들을 해결하고자 하였습니다.

테스트를 진행할 때는 독립적으로 실행되어야 합니다.

모든 테스트는 순서와 상관없이 실행되어야 하기 때문에, 의존관계가 있는 테스트는 좋은 테스트가 아니라고 볼 수 있습니다.

그래서 테스트가 끝나면 다른 테스트에 영향을 끼치지 않게끔, 이전 결과의 데이터를 지워줄 필요가 있습니다.
- `@AfterEach` : 각 테스트가 종료된 후 이 어노테이션이 붙어있는 메소드가 실행됨
- 이 어노테이션을 이용해 테스트가 종료될 때 마다 데이터를 지워주었음

## 회원 서비스 개발

주요 로직이 아닌 서브 기능들은 따로 메소드로 빼는 것이 좋습니다.

이름을 작성할 때는 보통 클래스의 역할에 맞게 메소드 이름을 작성하는 것이 좋습니다.

## 회원 서비스 테스트

#### given-when-then 패턴
- given : 이 데이터를 기반으로
- when : 이 로직을 실행한
- then : 결괏값을 검증

MemberService 에서도 MemberRepository 객체를 생성해두었고, MemberServiceTest 클래스에서도 MemberRepository 객체를 생성하는 경우, 서로 다른 객체를 생성하는 것이 됩니다.

이렇게 서로 다른 객체를 쓰게 되면, 내가 원하는 테스트 결과와 다른 결과를 볼 수도 있습니다.

( 서로 객체가 다르기 때문에, 내부 값 또한 다를 수 있음 )

그러므로 하나의 객체만을 가지고 사용하도록 구조를 변경할 필요가 있습니다.

```java
private final MemberRepository memberRepository;

public MemberService(MemoryMemberRepository memberRepository) {
    this.memberRepository = memberRepository;
}
```

이렇게 외부에서 클래스를 가져와 주입해주는 방식을 DI ( Dependency Injection ) 라 하며, 의존성 주입이라고 부릅니다.
