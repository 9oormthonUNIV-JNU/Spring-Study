###### *전체 코드는 개인 repository에 저장, 중요개념만 작성
### MVC
---
##### MVC : Model, View, Controller
![image](https://github.com/9oormthonUNIV-JNU/Spring-Study/assets/123622993/5492f01d-e491-4de6-b56c-673e45c5e7ae)

브라우저 -> local8080/hello-mvc -> 톰켓 서버 -> 컨트롤러 -> 메서드 호출 -> spring view Resolver(view 찾고 template 연결)

-> HTMl 변환 -> 웹브라우저 변환

##### django와의 차이점
* django는 MTV(Model, Template, View) 패턴으로 작동함.
* spring의 Model = django의 Model

  spring의 view = django의 Template

  spring의 Controller = django의 View  => django의 view와 spring의 view는 다름.




### API
---
![image](https://github.com/9oormthonUNIV-JNU/Spring-Study/assets/123622993/c8f5ee95-9e0a-42ad-8567-e3571476fbba)
  
* viewResolver 대신 HttpMessageConverter 동작 그 외는 같음.
* 기본 문자처리: StringHttpMessageConverter
  기본 객체처리: MappingJackson2HttpMessageConverter



### 스프링 빈
---
##### DI(Dependency Injection) : 객체 의존관계를 외부에서 넣어주는 것 => 생성자에 @Autowired
* 컴포넌트 스캔
@component를 포함하는 애노테이션(@Controller @Service @repository) 사용

기본적으로 싱글톤 사용

직접 작성한 객체에서는 동작 X
* 직접 스프링 빈 등록
```
@Bean
 public MemberService memberService() {
 return new MemberService(memberRepository());}
```


### spring DB
---
##### 테이블 생성
create table member
```
(
 id bigint generated by default as identity,
 name varchar(255),
 primary key (id)
);
```

##### Jdbc Template
---
* 생성자에서 DataSource를 필요로 함
* 장점
설정이 편리
반복문제 해결
SQL 작성, 파라미터 정의 , 응답 값 매핑만 하면되어 편리
* 단점
동적 쿼리문 해결 어려움

##### JPA
---
* 객체중심의 설계
* ORM(Object-Relational Mapping)의 기술 표준으로 사용하는 인터페이스 모음
* Hibernate, OpenJPA등이 구현
* 반복적인 CRUD SQL 처리

##### 스프링 데이터 JPA
* 인터페이스 만으로 개발 가능
* 훨씬 편리하게 개발 가능
* 동적 쿼리는 Querydsl 라이브러리 사용

##### AOP
컨테이너에 스프링 빈을 등록할 떄 procy(가짜 멤버 서비스)을 앞에 세워놓고, 가짜 스프링 빈이 끝나면 진짜 멤버 서비스 호출
